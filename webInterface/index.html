<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Web Interface</title>
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <link rel="stylesheet" type="text/css" href="styles.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      background: #1A1A1A; /* Neutral background color */
      color: white;
      font-family: 'Inter', sans-serif;
    }

    .matrix-container {
    position: relative;
    width: 100%;
    height: 400px; /* Increase height for better spacing */
    display: flex;
    flex-direction: column; /* Stack title and typing container vertically */
    align-items: center; /* Center items horizontally */
    justify-content: center; /* Center items vertically */
    overflow: hidden; /* Hide the matrix overflow */
    background: linear-gradient(to bottom, #0D1117, #1A1A1A);
}

    #matrix {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #pause-button {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 10px 15px;
        background-color: #252525;
        color: white;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3 ease;
        z-index: 2;
    }

    #pause-button:hover {
        background-color: #3a3a3a;
    }

    #typing-container {
    font-family: 'Garamond', sans-serif;
    font-weight: 300;
    color: white;
    text-align: center;
    position: relative;
    z-index: 1;
    margin-top: 15px; /* Adjust margin for spacing below the title */
    font-size: 2rem;
    white-space: nowrap; /* Prevent text wrapping */
    overflow: hidden; /* Hide overflowing text during typing animation */
    border-right: 2px solid white; /* Simulate a blinking cursor */
    height: 2.5rem; /* Fixed height based on the font size */
    line-height: 2.5rem; /* Center the text vertically */
    animation: blink 0.7s steps(1) infinite;
    }

/* Cursor blink effect */
@keyframes blink {
  50% {
    border-color: transparent;
  }
}

    h1 {
        position: relative;
        z-index: 1;
        font-size: 6rem;
        font-weight: 300;
        text-align: center;
        margin: 0; /* Remove any default margin */
        text-shadow: 
            0 0 10px rgba(173, 216, 230, 0.4),
            0 0 20px rgba(173, 216, 230, 0.3),
            0 0 30px rgba(147, 112, 219, 0.2);
        transition: all 0.3s ease-in-out;
}
    
    h1:hover {
    text-shadow: 
      0 0 15px rgba(173, 216, 230, 0.6), 
      0 0 25px rgba(173, 216, 230, 0.5), 
      0 0 40px rgba(147, 112, 219, 0.4);
    transform: scale(1.05);
    }
    
    .cards-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1.5rem;
        background-color: transparent;
        padding: 2rem 1rem;
    }

    .card{
        background-color: #1E1E1E;
        color: white;
        width: calc(33.33% - 1rem); /* Adjust width based on the number of cards */
        min-width: 200px;
        padding: 1.5rem;
        text-align: center;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
        position: relative;
        overflow: hidden;
        z-index: 1;
    }
    .card h2{
        font-size: 1.5rem;
        margin: 0;
        font-family: 'Inter', sans-serif;
    }

    .card:hover{
        transform: scale(1.05);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
        background-color: #252525;
    }

    .card:hover::after{
        content: '';
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        border-radius: 12px;
        box-shadow: 0 0 15px rgba(173, 216, 230, 0.7);
        z-index: -1;
    }

    .spacer {
        flex-basis: 100%;
        height: 2rem;
    }

    @import url("https://fonts.googleapis.com/css2?family=PT+Sans+Narrow:wght@400;700&display=swap");
    body {
      margin: 0;
      padding: 0;
    }

    #grid {
      position: fixed; /* Make it stay in the background */
      top: 0;
      left: 0;
      width: 100vw; /* Full viewport width */
      height: 100vh; /* Full viewport height */
      z-index: -1; /* Send it behind all other elements */
      pointer-events: none; /* Prevent it from blocking clicks */
      background: #16dfaa;
    }

    .k-hold {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 354px;
      height: 354px;
      margin-left: -177px;
      margin-top: -177px;
      cursor: pointer;
    }

    .k-black {
      display: block;
      width: 354px;
      height: 354px;
      position: absolute;
      top: 0;
      left: 0;
    }

    .k-enter {
      display: block;
      width: 354px;
      height: 354px;
      position: absolute;
      top: 0;
      left: 0;
      border: none;
      background: transparent;
      cursor: pointer;
      color: #fff;
      font-size: 40px;
      text-transform: uppercase;
      font-family: "PT Sans Narrow", Impact, sans-serif;
      font-weight: 700;
    }

    .k-stroke {
      opacity: 1;
      stroke-linecap: round;
      stroke-linejoin: mitter;
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
    }

    .k-black__stroke {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      -webkit-transform: translateZ(100px) scaleX(-1);
      transform: translateZ(100px) scaleX(-1);
    }

    .k-black__stroke svg {
      position: absolute;
      top: 50%;
      left: 50%;
      -webkit-transform: translate3d(-50%, -50%, 0);
      transform: translate3d(-50%, -50%, 0);
    }

    @media (max-width: 768px) {
        .card {
            width: 100%;
        }
    }


  </style>
</head>
<body>
  <!-- Libraries-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://rawgit.com/vonWolfehaus/von-grid/master/dist/hex-grid.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.6.0/Tween.min.js"></script>

  <div id="grid"></div> 
    <div class="matrix-container">
     <canvas id="matrix"></canvas>
      <h1 class="hover:rotate-180 hover:opacity-75 text-4xl font-light">Dissolve.dev</h1>
      <div id="typing-container" class="mt-4 text-3xl text-white text-center"></div>
   </div>
      <button id="pause-button">Pause</button>

  <div class="cards-container mx-auto mt-8 p-4">
    <!--card 1-->
    <div id="card-a" class="card" onclick="window.location.href='https://github.com/jessecastillo';">
        <h2 class="">Github Profile</h2>
    </div>


    <!--card 2-->

    <div id="card-b" class="card" onclick="window.location.href='https://wisdomwear.net';">
        <h2 class="">WisdomWear.net</h2>
    </div>


    <!--card 3-->

    <div id="card-c" class="card">
        <h2 class="">Coming Soon!</h2>
    </div>


    <div class="spacer"></div>

    <div id="card-4" class = "card">
        <h2>Card 4</h2>
    </div>
    <div id="card-5" class = "card">
        <h2>Card 5</h2>
    </div>
    <div id="card-6" class = "card">
        <h2>Card 6</h2>
     </div>

    </div>
    </div>

  <script>
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');
    const pauseButton = document.getElementById('pause-button');

    const container = document.querySelector('.matrix-container');
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;

    const fontSize = 16;
    const columns = Math.floor(canvas.width / fontSize);
    const drops = Array(columns).fill(0);

    const title = document.querySelector('h1');
    const textAnimationContainer = document.getElementById('typing-container'); // Reuse existing element

    let gravity  = 0.08;

    // Adjust for canvas position
    function getBoundingBoxes() {
        const canvasBox = canvas.getBoundingClientRect();
        const titleBox = title.getBoundingClientRect();
        const typingBox = textAnimationContainer.getBoundingClientRect();

  return {
    titleBox: {
      left: titleBox.left - canvasBox.left,
      right: titleBox.right - canvasBox.left,
      top: titleBox.top - canvasBox.top,
      bottom: titleBox.bottom - canvasBox.top,
    },
    typingBox: {
      left: typingBox.left - canvasBox.left,
      right: typingBox.right - canvasBox.left,
      top: typingBox.top - canvasBox.top,
      bottom: typingBox.bottom - canvasBox.top,
    },
  };
}

// Store characters affected by physics
const fallenChars = [];

// Simulate gravity for fallen characters
function applyPhysics() {
  for (let i = 0; i < fallenChars.length; i++) {
    const char = fallenChars[i];
    char.y += char.vy; // Apply vertical velocity
    char.vy += gravity; // Simulate gravity

    // Apply horizontal movement if there's a direction
    char.x += char.vx;

    // Render the character
    ctx.fillText(char.char, char.x, char.y);

    // Remove the character if it goes off-screen
    if (char.y > canvas.height || char.x < 0 || char.x > canvas.width) {
      fallenChars.splice(i, 1);
      i--;
    }
  }
}

// Draw the characters with collision detection
function drawMatrix() {
  ctx.fillStyle = '#0D1117';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#D8BFD8';
  ctx.font = `${fontSize}px monospace`;

  const { titleBox } = getBoundingBoxes();

  for (let i = 0; i < drops.length; i++) {
    const x = i * fontSize;
    const y = drops[i] * fontSize;

    // Check for collisions
    const isInTitle =
      x > titleBox.left && x < titleBox.right && y > titleBox.top && y < titleBox.bottom;
    const isNearTitle =
      (x < titleBox.left - 20 || x > titleBox.right + 20) &&
      y > titleBox.top - 50 &&
      y < titleBox.bottom + 50;

      if (isInTitle && Math.random() > 0.6) {

      // Add the character to fallenChars with initial physics properties
      fallenChars.push({
        char: String.fromCharCode(0x30A0 + Math.random() * 96),
        x: x,
        y: y,
        vx: Math.random() * 2 - 1, // Slight horizontal direction
        vy: -2, // Initial upward velocity to make it "bounce"
      });
            // Reset drop to start from top
            drops[i] = 0;
    } else if (isNearTitle && Math.random() > 0.85) {
        fallenChars.push({ 
            char: String.fromCharCode(0x30A0 + Math.random() * 96),
            x: x,
            y: y,
            vx: Math.random() * 1 - 0.5, // Slower horizontal velocity for side characters
            vy: 0.5, // Gentle fall for nearby characters
        });
        drops[i] = 0;
    } else if (Math.random() > 0.95) {
      ctx.fillText(
        String.fromCharCode(0x30A0 + Math.random() * 96), x, y);
      
    } 


    // Reset drop if it reaches the bottom
    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }

    drops[i]++;
  }

    applyPhysics();
}

    // Animation loop
    let isRunning = true;
    let lastFrameTime = 0;
    const fpsInterval = 1000 / 30;

    function animate(currentTime) {
    if (!isRunning) return;

    const elapsed = currentTime - lastFrameTime;
    if (elapsed >= fpsInterval) {
        lastFrameTime = currentTime;
        drawMatrix();
    }
    requestAnimationFrame(animate);
    }


    // Pause/resume logic
    container.addEventListener('mousedown', () => {
    isRunning = false;
    });
    container.addEventListener('mouseup', () => {
    isRunning = true;
    requestAnimationFrame(animate);
    });

    // Handle resizing
    window.addEventListener('resize', () => {
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    drops.length = Math.floor(canvas.width / fontSize);
    drops.fill(0);
    });

    title.addEventListener('mouseenter', () => {
        gravity = .9;
    });

    title.addEventListener('mouseleave', () =>{
        gravity = 0.08;
    })

    // Toggle animation on button click
    pauseButton.addEventListener('click', () => {
    isRunning = !isRunning;
    pauseButton.textContent = isRunning ? 'Pause' : 'Play';
    if (isRunning) {
        requestAnimationFrame(animate); // Restart the animation loop if resumed
    }
});

// Start the animation
requestAnimationFrame(animate);
  </script>

    <script>
    const typingContainer = document.getElementById('typing-container');
  
    // Text sequences
    const texts = ["Jesse Castillo", "DJ Merixium", "Ponder"];
    let textIndex = 0; // Current text index
    let charIndex = 0; // Current character index
    let isDeleting = false; // Whether we're deleting text
    const typingSpeed = 75; // Typing speed in ms
    const deletingSpeed = 50; // Deleting speed in ms
    const pauseTime = 1500; // Pause before deleting or moving to next text
  
    function type() {
      const currentText = texts[textIndex];
      if (isDeleting) {
        // Delete characters
        charIndex--;
        typingContainer.textContent = currentText.substring(0, charIndex);
      } else {
        // Type characters
        charIndex++;
        typingContainer.textContent = currentText.substring(0, charIndex);
      }
  
      // Adjust timing based on typing/deleting
      const currentSpeed = isDeleting ? deletingSpeed : typingSpeed;
  
      if (!isDeleting && charIndex === currentText.length) {
        // Pause before deleting
        setTimeout(() => (isDeleting = true), pauseTime);
      } else if (isDeleting && charIndex === 0) {
        // Move to the next text
        isDeleting = false;
        textIndex = (textIndex + 1) % texts.length; // Loop back to the start
      }
  
      setTimeout(type, currentSpeed);
    }
  
    // Start the typing effect
    type();
  </script>

  <script>
    const scene = new vg.Scene(
  {
    element: document.getElementById("grid"),
    light: new THREE.DirectionalLight(0x16dfaa, 0.2),
    lightPosition: {
      x: 0,
      y: 0,
      z: 0
    },
    cameraPosition: {
      x: 0,
      y: 10,
      z: 0
    }
  },
  false
); // false to OrbitControls

const tweenCameraY = new TWEEN.Tween(scene.camera.position)
  .to({ y: 500 }, 3000)
  .start();

// this constructs the cells in grid coordinate space
const grid = new vg.HexGrid({
  cellSize: 18 // size of individual cells
});

grid.generate({
  size: 36 // size of the board
});

const mouse = new vg.MouseCaster(scene.container, scene.camera);
const board = new vg.Board(grid);

// this will generate extruded hexagonal tiles
board.generateTilemap({
  tileScale: 0.945,
  material: new THREE.MeshPhongMaterial({
    color: 0x080808
  })
});

scene.add(board.group);
scene.focusOn(board.group);
mouse.signal.add(function (evt, tile) {
  if (evt === vg.MouseCaster.OVER) {
    let cell = board.grid.pixelToCell(mouse.position);
    if (cell) {
      (function (cell) {
        let cells = board.grid.getNeighbors(cell, false);
        cells.forEach((item, index) => {
          let t = board.getTileAtCell(item);
          let tween = new TWEEN.Tween(t.position)
            .easing(TWEEN.Easing.Quadratic.Out)
            .to({ y: [10, 0] }, 500 + index * 80)
            .start();
        });
      })(cell);
    }
  }
}, this);

function bumpCells(cell) {
  let cells = [];

  let l = board.grid._directions.length;
  let f = Math.floor(Math.random() * l); // from
  let t = Math.floor(Math.random() * (l - 2)) + 3; // total

  for (let i = 0; i < t; i++) {
    let c = new vg.Cell();

    let j = i + f;
    if (j >= l) {
      j -= l;
    }

    c.copy(cell);
    c.add(board.grid._directions[j]);
    let n = board.grid.cells[board.grid.cellToHash(c)] || null;
    if (n) {
      cells.push(n);
    }
  }

  // add central cell
  cells.push(cell);

  cells.forEach((item, index) => {
    let t = board.getTileAtCell(item);
    if (t) {
      let tween = new TWEEN.Tween(t.position)
        .easing(TWEEN.Easing.Quadratic.Out)
        .to({ y: [20, 0] }, 600 + index * 80)
        .start();
    }
  });
}

let _time = 0;

update();

function update(time) {
  if (time - _time > 2000) {
    for (let i = 0; i < 2; i++) {
      let cell = board.grid.getRandomCell();
      (function (cell) {
        bumpCells(cell);
      })(cell);
    }

    _time = time;
  }

  mouse.update();
  scene.render();
  TWEEN.update();
  requestAnimationFrame(update);
}

  </script>
</body>
</html>